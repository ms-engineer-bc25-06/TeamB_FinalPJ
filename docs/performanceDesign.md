# 性能設計書

## 目的

> 本ドキュメントは、感情教育アプリ『きもちみっけ！』の性能設計について定義する。ユーザー体験の向上とシステムの安定性を確保するため、適切な性能要件と対策を実装する。
> すでに実装しているものには（実装済み）と記載。

- ユーザー体験（UX）の向上: 体感速度・安定性の改善
- 障害防止: 性能劣化やボトルネックの早期検知・予防
- 将来拡張: ユーザー増加・機能追加時でも性能を維持できる基盤整備

## このドキュメントの使い方

性能要件や最適化方針を確認したい時に参照してください。パフォーマンス改善や負荷テストの設計に使用します。

## 1. 概要・対象システム

- フロントエンド: Next.js (TypeScript)
- バックエンド: FastAPI (Python)
- データベース: PostgreSQL
- ストレージ: AWS S3
- 音声処理: OpenAI Whisper (tiny モデル)

## 2. 性能要件（SLO/SLA）

前提

- P95: 全リクエストの 95%が 500ms 未満で完了すること
- P99: 全リクエストの 99%が 800ms 未満で完了すること
  （初期値。実測を踏まえ四半期ごとに見直す）

### 2.1 レスポンス時間

- API レスポンス: P95 < 500ms、P99 < 800ms
- 音声認識処理: P95 < 10 秒（30 秒以内の音声）
- ページ表示（LCP）: P75 < 2.5 秒（モバイル優先）
- DB クエリ: P95 < 300ms（単純クエリ）

### 2.2 スループット

- 同時接続数: 100 ユーザー以上
- リクエスト/秒: 50 RPS 以上
- 音声処理: 10 ファイル/分以上
- データベース接続: 20 接続以上

### 2.3 可用性

- システム稼働率: 99.5%以上
- エラー率: < 1%
- ダウンタイム: 月間 4 時間以内

## 3. 計測対象と方法

現状未導入のため、以下は方針として記載する。

### 3.1 API

- 対象: エンドポイント別レイテンシ（P50/P95/P99）、ステータスコード別エラー率
- 方法:
  - 初期: FastAPI ミドルウェアで構造化ログ出力（JSON）
    - 選定理由: 導入コストが低く、コードベース内で即時に可観測化を開始できるため
  - 将来: Prometheus + Grafana でメトリクス化・可視化
    - 選定理由: OSS 標準スタックで学習コスト・拡張性・運用実績が豊富なため
- 指標: API P95 < 500ms、P99 < 800ms、エラー率 < 1%

### 3.2 フロントエンド

- 対象: LCP, FID/INP, CLS, TTFB
- 方法:
  - 初期: Lighthouse（CI/手元）、Next.js Web Vitals ログ
    - 選定理由: 小さく始めやすく、CI でレグレッション検知が容易なため
  - 将来: RUM（例: Vercel Analytics, Google Analytics 4）
    - 選定理由: 実ユーザー環境での実測が可能で、端末・ネットワーク差分を把握できるため
- 指標: LCP P75 < 2.5 秒、CLS < 0.1、INP P75 < 200ms

### 3.3 データベース

- 対象: クエリ実行時間、スロークエリ件数、接続数
- 方法:
  - 初期: SQLAlchemy イベントフックでクエリ時間を計測・ログ
    - 選定理由: 既存スタックに自然に組み込みやすく、遅延箇所の把握が容易なため
  - 将来: pg_stat_statements + 可視化（Grafana）
    - 選定理由: 実運用で定番の指標を取得でき、クエリ別の最適化に有効なため
- 指標: DB クエリ P95 < 300ms（単純クエリ）

### 3.4 音声処理

- 対象: Whisper 前後の処理時間、入力ファイル長・最適化有無・成功率
- 方法: アプリ内計測 + 構造化ログ、将来的にメトリクス化
  - 選定理由: アプリ固有の処理であり、コード内計測が最も低コストで正確なため
- 指標: 音声処理 P95 < 10 秒、失敗率 < 1%

## 4. 改善方針

- しきい値超過時の対応:
  - 通知: Discord の運用チャンネルへ自動通知（初期はログ監視 → 将来は Alert Manager）
  - 記録: 事象・メトリクス・再現条件を Notion に集約
  - 追跡: GitHub 自動 Issue 化（テンプレート化、担当者・期限付与）
- 実測後の具体化: 初期仮値 → 実測 → ボトルネック特定 → 対策 → 再計測 → 基準更新のサイクル

## 5. 個別の性能設計

### 5.1 データベース

#### 5.1.1 インデックス設計（実装済み）

#### 2.1.1 主要インデックス

```python
# models.py で実装済み
class User(Base):
    uid: Mapped[str] = mapped_column(String, unique=True, nullable=False, index=True)
    email: Mapped[str] = mapped_column(String, unique=True, nullable=False, index=True)

class Subscription(Base):
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, unique=True, index=True)

class Child(Base):
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)

class EmotionLog(Base):
    child_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("children.id"), nullable=False, index=True)
```

#### 2.1.2 複合インデックス（未実装）

- **emotion_logs(user_id, child_id, created_at)**: ユーザー別・子ども別の感情ログ検索
- **daily_reports(child_id, created_at)**: 日次レポート検索
- **weekly_reports(user_id, child_id, week_start_date)**: 週次レポート検索

**注意**: 現在は単一カラムのインデックスのみ実装済み。複合インデックスは将来の最適化で実装予定。

### 2.2 クエリ最適化

#### 2.2.1 効率的なクエリ設計

- **JOIN 最小化**: 必要なテーブルのみ結合
- **LIMIT 使用**: 大量データ取得時の制限
- **適切な WHERE 句**: インデックスを活用する条件

#### 2.2.2 ページネーション

- **実装**: LIMIT/OFFSET ベースページネーション（実装済み）
- **効果**:
  - メモリ使用量の削減
  - レスポンス時間の安定化

**注意**: 現在は単純な LIMIT/OFFSET を実装。カーソルベースページネーションは未実装。

---

#### 5.2.1 モデル選択（実装済み）

### 3.1 Whisper 最適化（実装済み）

#### 3.1.1 モデル選択

```python
# whisper.py で実装済み
_DEFAULTS = {
    "model_name": os.getenv("WHISPER_MODEL_SIZE", "tiny"),  # 速度重視
    "temperature": float(os.getenv("WHISPER_TEMPERATURE", "0.0")),
    "beam_size": int(os.getenv("WHISPER_BEAM_SIZE", "1")),  # 速度重視
    "best_of": int(os.getenv("WHISPER_BEST_OF", "1")),      # 速度重視
}
```

#### 5.2.2 音声最適化（実装済み）

```python
# audio.py で実装済み
def normalize_to_wav16k_mono(src: str, dst: str) -> None:
    _run([
        "ffmpeg",
        "-y",
        "-i", src,
        "-ac", "1",          # モノラル
        "-ar", "16000",      # 16kHz
        "-c:a", "pcm_s16le", # 16bit PCM
        "-af", "silenceremove=start_periods=1:start_threshold=-35dB:start_silence=0.2:detection=peak,"
              "loudnorm=I=-20:TP=-1.0:LRA=11",  # 無音除去 + 音量正規化
        dst,
    ])
```

#### 5.2.3 ファイルサイズ最適化

- 形式: WebM、WAV、MP3
- 変換: 16kHz/モノラル/16bit（アップロード時間短縮・成功率向上）
- 制限: 最大 10MB（アップロード時間の予測可能化、コスト制御）

## 4. S3 連携の性能設計

### 4.1 直接アップロード方式

#### 4.1.1 概要

- **方式**: Presigned URL を使用した S3 直接アップロード
- **フロー**: フロントエンド → S3（サーバーを経由しない）
- **性能効果**:
  - サーバーの負荷軽減
  - アップロード速度の向上
  - スケーラビリティの向上

#### 4.1.2 性能比較

| 方式             | フロー                         | サーバー負荷       | アップロード速度 | スケーラビリティ       |
| ---------------- | ------------------------------ | ------------------ | ---------------- | ---------------------- |
| 従来方式         | フロントエンド → サーバー → S3 | 高（ファイル転送） | 中（2 段階転送） | 低（サーバー容量依存） |
| 直接アップロード | フロントエンド → S3            | 低（URL 生成のみ） | 高（直接転送）   | 高（S3 容量依存）      |

**実装詳細**:

- Presigned URL を使用した S3 直接アップロード
- ファイルタイプ別の有効期限設定（音声: 1 時間、テキスト: 2 時間）
- エラーハンドリングとログ記録を実装

---

## 5. キャッシュ戦略

### 5.1 アプリケーションレベルキャッシュ

#### 5.1.1 Whisper モデルキャッシュ（実装済み）

- **対象**: Whisper AI モデル
- **方式**: アプリケーション起動時にメモリに読み込み
- **効果**:
  - 音声認識処理の高速化
  - モデル読み込み時間の削減

#### 5.1.2 感情カードマスタ（未実装）

- **対象**: emotion_cards, intensity
- **方式**: アプリケーション起動時にメモリに読み込み
- **効果**:
  - データベースアクセス削減
  - レスポンス時間短縮

**注意**: 現在は画像 URL が相対パス（`/images/emotions/ureshii.webp`）で保存されているため、CDN 導入時は画像 URL の動的生成が必要。
本番環境では CDN URL への動的変換を計画中

#### 5.1.3 ユーザー情報キャッシュ（未実装）

- **対象**: 認証済みユーザー情報
- **方式**: セッション期間中キャッシュ
- **効果**:
  - 認証処理の高速化
  - データベース負荷軽減

### 5.2 CDN 活用

#### 5.2.1 静的ファイル配信（本番環境予定）

- **対象**: 感情カード画像、音声ファイル、その他静的アセット
- **方式**: CloudFront 等の CDN 使用
- **効果**:
  - 配信速度向上（グローバルエッジロケーション）
  - サーバー負荷軽減
  - 帯域幅コスト削減

**現在の状況**:

- 開発環境: フロントエンドの`public/images`に配置
- データベース: 相対パス（`/images/emotions/ureshii.webp`）で保存
- 本番環境: CDN URL への動的変換を計画中

**実装時の考慮事項**:

- 環境変数で CDN ベース URL を管理
- 画像 URL 生成用のユーティリティ関数が必要
- 既存データの移行スクリプトが必要

---

## 6. 監視・メトリクス

現状未導入のため、以下は方針として記載する。

### 6.1 対象

#### 6.1.1 ヘルスチェック（実装済み）

```python
# voice.py で実装済み
@router.get("/health", summary="音声APIヘルスチェック", description="音声APIの稼働状態を確認")
async def health_check():
    # S3設定の確認
    from app.utils.constants import S3_BUCKET_NAME
    s3_status = "configured" if S3_BUCKET_NAME else "not_configured"

    return {
        "status": "healthy",
        "service": "voice-api",
        "s3_bucket": S3_BUCKET_NAME,
        "s3_status": s3_status,
    }
```

#### 6.1.2 性能指標

- **レスポンス時間**: API レスポンス < 500ms
- **スループット**: 同時接続数 100 以上
- **リソース使用率**: CPU < 70%, メモリ < 80%

- ユーザー体感の劣化・障害の予兆を早期に検知し、回避・復旧を迅速化するため

#### 6.2.1 性能アラート

- **レスポンス時間**: 1 秒超過
- **エラー率**: 5%超過
- **リソース使用率**: 80%超過

- 初期: 構造化ログ（JSON）
  - 理由: 導入が軽量で、すぐに計測と可視化ができる
- 将来: Prometheus + Grafana
  - 理由: 標準的・拡張性が高く、長期運用に耐える

### 6.4 指標

- API: P95 < 500ms、P99 < 800ms、エラー率 < 1%
- DB クエリ時間（P95）、接続数、スロークエリ
- 音声処理時間（P95）、失敗率
- フロント Web Vitals（LCP/CLS/INP）

## 7. 負荷テスト設計

現状未導入のため、以下は方針として記載する。

### 7.1 対象

#### 7.1.1 基本負荷テスト

- **同時ユーザー**: 50 ユーザー
- **テスト時間**: 15 分
- **測定項目**: レスポンス時間、エラー率、スループット

#### 7.1.2 音声処理負荷テスト

- **同時音声処理**: 10 ファイル
- **ファイルサイズ**: 5MB 以下
- **測定項目**: 処理時間、成功率、リソース使用率

- ユーザー増加時にどこから性能劣化が始まるかを把握し、ボトルネックを特定する

#### 7.2.1 推奨ツール

- **Locust**: Python 製負荷テストツール
- **JMeter**: Java 製負荷テストツール
- **Artillery**: Node.js 製負荷テストツール

#### 7.2.2 テスト環境

- **本番同等環境**: Docker Compose 環境
- **データ量**: 本番の 10%程度
- **ネットワーク**: ローカル環境

### 7.4 指標

- API: P95 < 500ms、失敗率 < 1%
- 音声処理: P95 < 10 秒
- ページ: LCP P75 < 2.5 秒

### 7.5 テスト種類

1. スモークテスト（短時間確認）

- 条件: 10 ユーザー / 3 分
- 目的: 主要フローが落ちずに動作するか

2. ランプテスト（負荷を徐々に増加）

- 条件: 10 → 30 → 50 ユーザー、各 5 分
- 目的: レスポンス悪化の分岐点を把握

3. ソークテスト（一定負荷を長時間）

- 条件: 20 ユーザー固定 / 30 分
- 目的: メモリリークや不安定化の検知

### 7.6 結果の共有方法

- Discord: サマリ共有
- Notion: 性能テスト DB に記録・比較
- GitHub: 自動 Issue 化（再現条件・スクリーンショット添付）

## 8. スケーラビリティ設計

現状未導入のため、以下は方針として記載する。

- 対象: アプリサーバ、DB、ストレージ
- 目的: 利用者増に伴い性能・可用性を維持するため

#### 8.1.1 アプリケーションサーバー

- **方式**: 複数インスタンスでの負荷分散
- **効果**:
  - 同時接続数の増加対応
  - 可用性の向上

#### 8.1.2 データベース

- **方式**: 読み取り専用レプリカ
- **効果**:
  - 読み取り負荷の分散
  - レスポンス時間の改善

### 8.2 指標

#### 8.2.1 リソース増強

- **CPU**: 必要に応じて増強
- **メモリ**: キャッシュ効果向上のため増強
- **ストレージ**: S3 の自動スケーリング活用

## 9. 実装優先度

### 9.1 高優先度（実装済み）

- [x] **基本インデックス最適化** - データベースクエリの高速化（単一カラム）
- [x] **音声最適化** - Whisper 処理の高速化
- [x] **ファイルサイズ制限** - アップロード時間の制御
- [x] **S3 直接アップロード** - サーバー負荷軽減
- [x] **非同期処理** - FastAPI + asyncpg による高速化
- [x] **Whisper モデルキャッシュ** - 音声認識処理の高速化
- [x] **LIMIT/OFFSET ページネーション** - 大量データ取得の制限

### 9.2 中優先度（実装予定）

- [ ] **性能測定システム構築** - 実際の性能数値の測定
- [ ] **負荷テスト実施** - スループット・同時接続数の検証
- [ ] **監視システム構築** - 性能指標の可視化
- [ ] **複合インデックス実装** - 複雑なクエリの高速化
- [ ] **感情カードマスタキャッシュ** - レスポンス時間の短縮
- [ ] **CDN 導入** - 静的ファイル配信の高速化
  - [ ] 画像 URL 動的生成機能
  - [ ] 既存データの移行スクリプト

### 9.3 低優先度（将来実装）

- [ ] **カーソルベースページネーション** - より効率的なページング
- [ ] **オフライン機能** - 要件定義書で要求されている機能
- [ ] **水平スケーリング** - 大規模化対応
- [ ] **高度なキャッシュ戦略** - Redis 等の導入
- [ ] **データベース最適化** - クエリチューニング
- [ ] **ユーザー情報キャッシュ** - 認証処理の高速化

### 9.3 低優先度（将来）

- [ ] 水平スケーリング
- [ ] Redis 等の高度キャッシュ
- [ ] クエリチューニングの継続

### 10.1 テスト実施スケジュール

- **開発環境**: 週次実施
- **ステージング環境**: リリース前実施
- **本番環境**: 月次実施

### 10.2 テスト結果の評価基準

- **合格基準**: 性能要件を満たす
- **改善基準**: 性能要件の 80%以上
- **要改善**: 性能要件の 80%未満

### 10.3 継続的改善

- **性能監視**: 24 時間監視
- **定期レビュー**: 月次レビュー
- **改善実施**: 四半期ごと
