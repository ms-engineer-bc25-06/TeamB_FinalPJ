# 性能設計書

## 目的
> 本ドキュメントは、感情教育アプリ『きもちみっけ！』の性能設計について定義する。ユーザー体験の向上とシステムの安定性を確保するため、適切な性能要件と対策を実装する。
すでに実装しているものには（実装済み）と記載。

- ユーザー体験（UX）の向上: 体感速度・安定性の改善
- 障害防止: 性能劣化やボトルネックの早期検知・予防
- 将来拡張: ユーザー増加・機能追加時でも性能を維持できる基盤整備

## このドキュメントの使い方

性能要件や最適化方針を確認したい時に参照してください。パフォーマンス改善や負荷テストの設計に使用します。

## 1. 概要・対象システム

- フロントエンド: Next.js (TypeScript)
- バックエンド: FastAPI (Python)
- データベース: PostgreSQL
- ストレージ: AWS S3
- 音声処理: OpenAI Whisper (tinyモデル)

## 2. 性能要件（SLO/SLA）

前提
- P95: 全リクエストの95%が500ms未満で完了すること
- P99: 全リクエストの99%が800ms未満で完了すること
（初期値。実測を踏まえ四半期ごとに見直す）

### 2.1 レスポンス時間

- API レスポンス: P95 < 500ms、P99 < 800ms
- 音声認識処理: P95 < 10秒（30秒以内の音声）
- ページ表示（LCP）: P75 < 2.5秒（モバイル優先）
- DB クエリ: P95 < 300ms（単純クエリ）

### 2.2 スループット

- 同時接続数: 100ユーザー以上
- リクエスト/秒: 50 RPS以上
- 音声処理: 10ファイル/分以上
- データベース接続: 20接続以上

### 2.3 可用性

- システム稼働率: 99.5%以上
- エラー率: < 1%
- ダウンタイム: 月間4時間以内

## 3. 計測対象と方法
現状未導入のため、以下は方針として記載する。

### 3.1 API 

- 対象: エンドポイント別レイテンシ（P50/P95/P99）、ステータスコード別エラー率
- 方法:
  - 初期: FastAPI ミドルウェアで構造化ログ出力（JSON）
    - 選定理由: 導入コストが低く、コードベース内で即時に可観測化を開始できるため
  - 将来: Prometheus + Grafana でメトリクス化・可視化
    - 選定理由: OSS標準スタックで学習コスト・拡張性・運用実績が豊富なため
- 指標: API P95 < 500ms、P99 < 800ms、エラー率 < 1%

### 3.2 フロントエンド

- 対象: LCP, FID/INP, CLS, TTFB
- 方法:
  - 初期: Lighthouse（CI/手元）、Next.js Web Vitals ログ
    - 選定理由: 小さく始めやすく、CIでレグレッション検知が容易なため
  - 将来: RUM（例: Vercel Analytics, Google Analytics 4）
    - 選定理由: 実ユーザー環境での実測が可能で、端末・ネットワーク差分を把握できるため
- 指標: LCP P75 < 2.5秒、CLS < 0.1、INP P75 < 200ms

### 3.3 データベース

- 対象: クエリ実行時間、スロークエリ件数、接続数
- 方法:
  - 初期: SQLAlchemy イベントフックでクエリ時間を計測・ログ
    - 選定理由: 既存スタックに自然に組み込みやすく、遅延箇所の把握が容易なため
  - 将来: pg_stat_statements + 可視化（Grafana）
    - 選定理由: 実運用で定番の指標を取得でき、クエリ別の最適化に有効なため
- 指標: DB クエリ P95 < 300ms（単純クエリ）

### 3.4 音声処理

- 対象: Whisper 前後の処理時間、入力ファイル長・最適化有無・成功率
- 方法: アプリ内計測 + 構造化ログ、将来的にメトリクス化
  - 選定理由: アプリ固有の処理であり、コード内計測が最も低コストで正確なため
- 指標: 音声処理 P95 < 10秒、失敗率 < 1%

## 4. 改善方針

- しきい値超過時の対応:
  - 通知: Discord の運用チャンネルへ自動通知（初期はログ監視→将来はAlert Manager）
  - 記録: 事象・メトリクス・再現条件を Notion に集約
  - 追跡: GitHub 自動Issue化（テンプレート化、担当者・期限付与）
- 実測後の具体化: 初期仮値→実測→ボトルネック特定→対策→再計測→基準更新のサイクル

## 5. 個別の性能設計

### 5.1 データベース

#### 5.1.1 インデックス設計（実装済み）

```python
# models.py で実装済み
class User(Base):
    uid: Mapped[str] = mapped_column(String, unique=True, nullable=False, index=True)
    email: Mapped[str] = mapped_column(String, unique=True, nullable=False, index=True)

class Subscription(Base):
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, unique=True, index=True)

class Child(Base):
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)

class EmotionLog(Base):
    child_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("children.id"), nullable=False, index=True)
```

#### 5.1.2 複合インデックス（推奨）

- emotion_logs(user_id, child_id, created_at)
- daily_reports(child_id, created_at)
- weekly_reports(user_id, child_id, week_start_date)

#### 5.1.3 クエリ最適化

- JOIN最小化、必要な列の選択、LIMIT活用
- カーソルベースページネーション（大量データ時の安定化）

### 5.2 音声処理（Whisper）

#### 5.2.1 モデル選択（実装済み）

```python
# whisper.py で実装済み
_DEFAULTS = {
    "model_name": os.getenv("WHISPER_MODEL_SIZE", "tiny"),  # 速度重視
    "temperature": float(os.getenv("WHISPER_TEMPERATURE", "0.0")),
    "beam_size": int(os.getenv("WHISPER_BEAM_SIZE", "1")),  # 速度重視
    "best_of": int(os.getenv("WHISPER_BEST_OF", "1")),      # 速度重視
}
```

#### 5.2.2 音声最適化（実装済み）

```python
# audio_optimizer.py で実装済み
def optimize_for_whisper(self, input_path: str) -> Optional[str]:
    cmd = [
        'ffmpeg',
        '-i', input_path,
        '-ar', '16000',      # 16kHz
        '-ac', '1',          # モノラル
        '-c:a', 'pcm_s16le', # 16bit PCM
        '-af', 'loudnorm',   # 音量正規化
        '-y', output_path
    ]
```

#### 5.2.3 ファイルサイズ最適化

- 形式: WebM、WAV、MP3
- 変換: 16kHz/モノラル/16bit（アップロード時間短縮・成功率向上）
- 制限: 最大10MB（アップロード時間の予測可能化、コスト制御）

### 5.3 S3 連携

- 方式: Presigned URL によるフロント→S3 直接アップロード（サーバ非経由）
- 効果: サーバ負荷軽減・転送の短縮・スケーラビリティ向上

### 5.4 キャッシュ戦略

- アプリケーションレベル: マスタデータ（emotion_cards, intensity）を起動時ロード
- ユーザー情報: セッション期間中キャッシュ
- CDN: 画像・音声などの静的配信に活用（将来導入）

## 6. 監視・メトリクス
現状未導入のため、以下は方針として記載する。

### 6.1 対象

- API 応答時間（P50/P95/P99）、エラー率
- DB クエリ時間（P95）、接続数、スロークエリ
- 音声処理時間（P95）、失敗率
- フロント Web Vitals（LCP/CLS/INP）

### 6.2 目的

- ユーザー体感の劣化・障害の予兆を早期に検知し、回避・復旧を迅速化するため

### 6.3 方法

- 初期: 構造化ログ（JSON）
  - 理由: 導入が軽量で、すぐに計測と可視化ができる
- 将来: Prometheus + Grafana
  - 理由: 標準的・拡張性が高く、長期運用に耐える

### 6.4 指標

- API: P95 < 500ms、P99 < 800ms、エラー率 < 1%
- DB クエリ時間（P95）、接続数、スロークエリ
- 音声処理時間（P95）、失敗率
- フロント Web Vitals（LCP/CLS/INP）

## 7. 負荷テスト設計
現状未導入のため、以下は方針として記載する。

### 7.1 対象

- ログインフロー、/emotion-logs API、音声処理リクエスト

### 7.2 目的

- ユーザー増加時にどこから性能劣化が始まるかを把握し、ボトルネックを特定する

### 7.3 方法

- k6: スクリプトが簡潔でCIに組み込みやすい
- Locust: Python ベースでシナリオ表現が柔軟
- Lighthouse: フロントの体感性能を自動評価

### 7.4 指標

- API: P95 < 500ms、失敗率 < 1%
- 音声処理: P95 < 10秒
- ページ: LCP P75 < 2.5秒

### 7.5 テスト種類

1. スモークテスト（短時間確認）

- 条件: 10ユーザー / 3分
- 目的: 主要フローが落ちずに動作するか

2. ランプテスト（負荷を徐々に増加）

- 条件: 10 → 30 → 50ユーザー、各5分
- 目的: レスポンス悪化の分岐点を把握

3. ソークテスト（一定負荷を長時間）

- 条件: 20ユーザー固定 / 30分
- 目的: メモリリークや不安定化の検知

### 7.6 結果の共有方法

- Discord: サマリ共有
- Notion: 性能テストDBに記録・比較
- GitHub: 自動Issue化（再現条件・スクリーンショット添付）

## 8. スケーラビリティ設計
現状未導入のため、以下は方針として記載する。

- 対象: アプリサーバ、DB、ストレージ
- 目的: 利用者増に伴い性能・可用性を維持するため

### 8.1 方法

- 水平スケーリング: コンテナオーケストレーション（現状 Docker Compose → 将来 Kubernetes）
- 垂直スケーリング: クラウドリソースの段階的増強（CPU/メモリ）

### 8.2 指標

- 同時接続数が 100 → 200 で API P95 が 500ms を超え始めたらスケール検討
- CPU 使用率 > 80% が継続、メモリ使用率 > 80% が継続でスケール判断

## 9. 実装優先度

### 9.1 高優先度（実装済み）

- [x] インデックス最適化（DBクエリ高速化）
- [x] 音声最適化（Whisper処理の高速化）
- [x] ファイルサイズ制限（アップロード時間の制御）

### 9.2 中優先度（実装予定）

- [ ] キャッシュ実装（レスポンス時間の短縮）
- [ ] CDN導入（静的ファイル配信の高速化）
- [ ] 監視基盤（性能指標の可視化）

### 9.3 低優先度（将来）

- [ ] 水平スケーリング
- [ ] Redis等の高度キャッシュ
- [ ] クエリチューニングの継続

## 10. 性能テストの実施計画

### 10.1 実施頻度

- 開発環境: 週次（短時間のスモーク／ランプ）
- ステージング: リリース前（ランプ／ソーク）
- 本番環境: 月次（短時間の健全性確認）

### 10.2 結果の評価基準

- 合格: 性能要件を満たす
- 改善: 性能要件の80%以上
- 要改善: 性能要件の80%未満

### 10.3 継続的改善サイクル

- 計測 → 可視化 → しきい値判定 → 対策 → 再計測 → 基準更新
