'use client';

import { useEffect, useMemo, useRef, useState } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useAuth } from '@/contexts/AuthContext';
import { getAudioConstraints, selectRecorderConfig, getErrorMessage } from '@/utils/audio';
import { colors, commonStyles, spacing, borderRadius } from '@/styles/theme';

type GetUploadUrlResponse = {
  success: boolean;
  upload_url: string;
  file_path: string;
  s3_url?: string;
  content_type: string;
};

type TranscriptionResult = {
  success: boolean;
  transcription_id: number;
  text: string;
  confidence: number;
  language: string;
  duration: number;
  processed_at: string;
};

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || '';

// ÂæÖ„Å°ÊôÇÈñì„ÅÆÂøúÊè¥„É°„ÉÉ„Çª„Éº„Ç∏Ôºà„É©„É≥„ÉÄ„É†ÂàáÊõøÔºâ
const WAIT_MESSAGES = [
  '„Åô„Åî„ÅÑÔºÅ „ÅÑ„Åæ „Åì„Å®„Å∞„Çí „Å≤„Çç„Å£„Å¶„Çã„Çà ‚ú®',
  '„ÇÇ„ÅÜ„Å°„Çá„Å£„Å®‚Ä¶ „Åä„Çì„Å∑„Çí „ÅÇ„Å§„ÇÅ„Å¶„Çã„Çà üéµ',
  '„Åì„Åì„Çç„Çì „Åã„Çì„Åå„Åà‰∏≠‚Ä¶ 3, 2, 1‚Ä¶ ü§î',
  '„Éî„Ç´„Éº„É≥ÔºÅ „Å≤„Çâ„ÇÅ„Åç „Åæ„Å°„Å†„Çà ‚ú®',
  '„Åò„Çá„ÅÜ„Åö„Å´ „ÅØ„Å™„Åõ„Åü„Å≠ÔºÅ „Çà„Åø„Åì„Åø‰∏≠‚Ä¶ ‚è≥',
];

export default function VoiceEntryPage() {
  const { user, isLoading } = useAuth();
  const router = useRouter();

  const searchParams = useSearchParams();
  const emotionId = searchParams.get('emotion');
  const intensityLevel = searchParams.get('intensity');
  const childId = searchParams.get('child');

  useEffect(() => {
    console.log('[EMOTION]', { emotionId, intensityLevel });
  }, [emotionId, intensityLevel]);

  const [checkingToday, setCheckingToday] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Èå≤Èü≥Á≥ª
  const [isRecording, setIsRecording] = useState(false);
  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
  const [status, setStatus] = useState<string>('');
  const [isBusy, setIsBusy] = useState(false);
  const [transcription, setTranscription] = useState<TranscriptionResult | null>(null);

  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<BlobPart[]>([]);
  const streamRef = useRef<MediaStream | null>(null);
  const recConfig = useMemo(() => selectRecorderConfig(), []);

  // ÂÜçÁîü
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);

  // ÂøúÊè¥„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
  const [msgIndex, setMsgIndex] = useState(0);

  const handleBack = () => router.push('/app/emotion-confirmation');

  // ====== „É¨„Ç§„Ç¢„Ç¶„Éà ======
  const LAYOUT = { maxWidth: 430, cardMaxWidth: 360 };
  const styles = {
    page: {
      background: 'url("/images/background.webp") no-repeat center center',
      backgroundSize: 'cover',
      minHeight: '100dvh',
      display: 'flex',
      flexDirection: 'column' as const,
      alignItems: 'center',
      justifyContent: 'center',
    },
    panel: {
      position: 'fixed' as const,
      top: 0,
      left: '50%',
      transform: 'translateX(-50%)',
      bottom: 0,
      padding: 'max(10px, env(safe-area-inset-top)) 0 max(16px, env(safe-area-inset-bottom)) 0',
      zIndex: 50,
      boxSizing: 'border-box' as const,
      width: 'min(100vw, 430px)',
      maxWidth: `${LAYOUT.maxWidth}px`,
      overflowX: 'hidden' as const,
      display: 'flex',
      flexDirection: 'column' as const,
      justifyContent: 'flex-start',
      alignItems: 'center',
      gap: 12,
      background: 'transparent',
    },
    backBtn: {
      position: 'fixed' as const,
      top: 20,
      left: 20,
      background: 'none',
      border: 'none',
      fontSize: 16,
      cursor: 'pointer',
      padding: 6,
      borderRadius: 6,
      color: '#000',
      zIndex: 200,
      fontWeight: 'bold' as const,
    },
    bubbleSmall: {
      marginTop: 60,
      background: '#fff',
      borderRadius: 12,
      padding: '8px 10px',
      boxShadow: '0 4px 10px rgba(0,0,0,0.1)',
      width: '88%',
      maxWidth: `${Math.min(320, LAYOUT.maxWidth)}px`,
      textAlign: 'center' as const,
    },
    bubbleTextSmall: { fontWeight: 700, fontSize: 14, lineHeight: 1.3, color: '#333' },

    characterWrap: {
      display: 'flex',
      flexDirection: 'column' as const,
      alignItems: 'center',
      gap: 8,
      marginTop: 10,
      marginBottom: 10,
    },
    characterImg: {
      width: 'min(70vw, 300px)',
      height: 'min(70vw, 300px)',
      objectFit: 'contain' as const,
    },

    // Èå≤Èü≥„Çª„ÇØ„Ç∑„Éß„É≥ÔºàÁôΩÊû†„Ç´„Éº„ÉâÔºâ
    recordCard: {
      marginTop: 8,
      padding: 12,
      borderRadius: 12,
      border: '1px solid #e5e7eb',
      background: '#fff',
      boxShadow: '0 1px 3px rgba(0,0,0,0.06)',
      width: '92%',
      maxWidth: `${Math.min(LAYOUT.cardMaxWidth, LAYOUT.maxWidth)}px`,
      textAlign: 'center' as const,
    },
    recordButtonWrap: {
      marginTop: 4,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      width: '100%',
    },
    recordOuter: {
      width: 220,
      height: 220,
      borderRadius: '50%',
      border: '8px solid #d1d5db',
      background: '#ffffff',
      display: 'grid',
      placeItems: 'center',
      boxShadow: '0 10px 24px rgba(0,0,0,0.18)',
      userSelect: 'none' as const,
      touchAction: 'manipulation' as const,
      WebkitTapHighlightColor: 'transparent',
      cursor: 'pointer',
      transition: 'transform 0.12s ease',
      position: 'relative' as const, // ‚è∏Èáç„Å≠Ë°®Á§∫„ÅÆ„Åü„ÇÅ
    },
    recordInnerIdle: {
      width: 160,
      height: 160,
      borderRadius: '50%',
      background: '#ef4444',
    },
    recordInnerActive: {
      width: 170,
      height: 170,
      borderRadius: '50%',
      background: '#ef4444',
      boxShadow: '0 0 0 6px rgba(239,68,68,0.25)',
    },
    // Èå≤Èü≥‰∏≠„ÅÆ‚è∏Ë°®Á§∫ÔºàÂêå„Åò„Éú„Çø„É≥ÂÜÖ„ÅßÈáç„Å≠„ÇãÔºâ
    pauseIconWrap: {
      position: 'absolute' as const,
      inset: 0,
      display: 'grid',
      placeItems: 'center',
      pointerEvents: 'none' as const,
    },
    pauseBars: {
      display: 'grid',
      gridAutoFlow: 'column',
      gap: 12,
    },
    pauseBar: {
      width: 18,
      height: 70,
      borderRadius: 6,
      background: '#ffffff',
      boxShadow: '0 0 0 1px rgba(0,0,0,0.05) inset',
    },
    recordHelper: {
      marginTop: 8,
      fontWeight: 700,
      color: '#111827',
    },

    // „Äå„Åç„ÅÑ„Å¶„Åø„Çã„Äç
    confirmCard: {
      marginTop: 16,
      padding: 12,
      borderRadius: 12,
      border: '1px solid #e5e7eb',
      background: '#fff',
      boxShadow: '0 1px 3px rgba(0,0,0,0.06)',
      width: '92%',
      maxWidth: `${Math.min(LAYOUT.cardMaxWidth, LAYOUT.maxWidth)}px`,
      textAlign: 'center' as const,
    },
    confirmTitle: { fontWeight: 700, marginBottom: 10, color: '#111827', fontSize: 18 },
    playButtonBase: {
      width: 200,
      height: 200,
      borderRadius: '50%',
      display: 'grid',
      placeItems: 'center',
      fontSize: 72,
      fontWeight: 900,
      cursor: 'pointer',
      margin: '12px auto',
      boxShadow: '0 10px 24px rgba(0,0,0,0.2)',
      userSelect: 'none' as const,
      touchAction: 'manipulation' as const,
      WebkitTapHighlightColor: 'transparent',
      color: '#111827',
      border: '8px solid transparent',
    },
    playButtonIdle: {
      background: '#facc15',
      borderColor: '#eab308',
    },
    playButtonActive: {
      background: '#ef4444',
      borderColor: '#b91c1c',
      color: '#ffffff',
    },

    confirmButtons: {
      display: 'grid',
      gridTemplateColumns: '1fr 1fr',
      gap: 10,
      marginTop: 14,
    },
    btnPrimary: {
      padding: '14px 16px',
      borderRadius: 12,
      background: '#10b981',
      color: '#fff',
      fontWeight: 800,
      fontSize: 18,
      border: 'none',
      cursor: 'pointer',
    },
    btnDanger: {
      padding: '14px 16px',
      borderRadius: 12,
      background: '#fca5a5',
      color: '#7f1d1d',
      fontWeight: 800,
      fontSize: 18,
      border: '2px solid #ef4444',
      cursor: 'pointer',
    },

    statusCard: (hasError: boolean) => ({
      marginTop: 8,
      padding: 10,
      borderRadius: 10,
      border: `1px solid ${hasError ? '#f5c2c7' : '#e5e7eb'}`,
      background: hasError ? '#fdecee' : '#fafafa',
      color: hasError ? '#842029' : '#111827',
      width: '92%',
      maxWidth: `${Math.min(LAYOUT.cardMaxWidth, LAYOUT.maxWidth)}px`,
      textAlign: 'center' as const,
      fontSize: 14,
    }),

    // === ÂæÖ„Å°ÊôÇÈñì„ÅÆÊºîÂá∫Ôºà„Ç™„Éº„Éê„Éº„É¨„Ç§Ôºâ ===
    overlay: {
      position: 'fixed' as const,
      inset: 0,
      background: 'rgba(0,0,0,0.2)',
      backdropFilter: 'blur(1px)',
      zIndex: 300,
      display: 'grid',
      placeItems: 'center',
    },
    waitCard: {
      width: 'min(88vw, 360px)',
      borderRadius: 16,
      background: '#ffffff',
      border: '1px solid #e5e7eb',
      boxShadow: '0 12px 30px rgba(0,0,0,0.25)',
      padding: 16,
      textAlign: 'center' as const,
    },
    waitKokoron: {
      width: 180,
      height: 180,
      objectFit: 'contain' as const,
      animation: 'bob 1.6s ease-in-out infinite',
      margin: '0 auto 8px',
    },
    waitBubble: {
      background: '#fff',
      borderRadius: 12,
      border: '1px solid #e5e7eb',
      padding: '8px 10px',
      margin: '0 auto 8px',
      fontWeight: 800,
      color: '#111827',
      width: '92%',
    },
    progressWrap: {
      width: '92%',
      height: 10,
      borderRadius: 999,
      background: '#f3f4f6',
      overflow: 'hidden' as const,
      margin: '6px auto 2px',
      border: '1px solid #e5e7eb',
    },
    progressBar: {
      width: '40%',
      height: '100%',
      borderRadius: 999,
      background: 'linear-gradient(90deg, #fde68a, #facc15, #f59e0b)',
      animation: 'indet 1.2s infinite',
    },
    waitHint: { fontSize: 12, color: '#6b7280', marginTop: 6 },
  } as const;
  // ====== „Åì„Åì„Åæ„Åß ======

  // ÂøúÊè¥„É°„ÉÉ„Çª„Éº„Ç∏ÂàáÊõøÔºàisBusy„ÅÆÈñì„Å†„ÅëÔºâ
  useEffect(() => {
    if (!isBusy) return;
    const id = setInterval(() => {
      setMsgIndex((i) => (i + 1) % WAIT_MESSAGES.length);
    }, 1500);
    return () => clearInterval(id);
  }, [isBusy]);

  // Ë™çË®º„ÉÅ„Çß„ÉÉ„ÇØ
  useEffect(() => {
    if (!isLoading && !user) router.replace('/');
  }, [isLoading, user, router]);

  // ‰ªäÊó•„ÅÆË®òÈå≤„ÉÅ„Çß„ÉÉ„ÇØ
  useEffect(() => {
    const checkToday = async () => {
      if (!user) return;
      if (!API_BASE) {
        setError('Áí∞Â¢ÉÂ§âÊï∞ NEXT_PUBLIC_API_BASE_URL „ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
        setCheckingToday(false);
        return;
      }
      try {
        const res = await fetch(`${API_BASE}/api/v1/voice/records/${user.id}`);
        if (!res.ok) throw new Error(`records ÂèñÂæóÂ§±Êïó: ${res.status}`);
        const data = await res.json();

        const todayYmd = new Date();
        const y = todayYmd.getFullYear();
        const m = String(todayYmd.getMonth() + 1).padStart(2, '0');
        const d = String(todayYmd.getDate()).padStart(2, '0');
        const ymd = `${y}${m}${d}`;

        const hasToday = (data?.records ?? []).some((r: any) => {
          if (Array.isArray(r?.created_at) && r.created_at[0]) return r.created_at[0] === ymd;
          const name = String(r?.audio_path || '');
          const m2 = name.match(/audio_(\d{8})_/);
          return m2?.[1] === ymd;
        });

        if (hasToday) {
          router.replace('/app/entries/today/edit');
          return;
        }
      } catch (e: any) {
        setError(e?.message || '‰ªäÊó•„ÅÆË®òÈå≤Á¢∫Ë™ç„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      } finally {
        setCheckingToday(false);
      }
    };
    if (user) checkToday();
  }, [user, router]);

  // --- Èå≤Èü≥ÈñãÂßã ---
  const startRecording = async () => {
    try {
      setError(null);
      setStatus('');
      setAudioBlob(null);
      setTranscription(null);
      setIsPlaying(false);

      const stream = await navigator.mediaDevices.getUserMedia(getAudioConstraints());
      streamRef.current = stream;

      const rec = new MediaRecorder(stream, recConfig.mimeType ? { mimeType: recConfig.mimeType } : undefined);
      mediaRecorderRef.current = rec;
      chunksRef.current = [];

      rec.ondataavailable = (e) => e?.data && e.data.size > 0 && chunksRef.current.push(e.data);
      rec.onerror = (ev) => setError(`Èå≤Èü≥„Ç®„É©„Éº: ${(ev as any).error?.message || 'unknown'}`);
      rec.onstop = () => {
        const blob = new Blob(chunksRef.current, { type: recConfig.contentType });
        setAudioBlob(blob);
        stopStream();
        setStatus('');
      };

      rec.start();
      setIsRecording(true);
    } catch (err: any) {
      console.error('[RECORDING] error', err);
      stopStream();
      setError(getErrorMessage(err));
      setStatus('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
      setIsRecording(false);
    }
  };

  // --- Èå≤Èü≥ÂÅúÊ≠¢ ---
  const stopRecording = () => {
    if (!isRecording) return;
    try {
      mediaRecorderRef.current?.stop();
    } finally {
      setIsRecording(false);
    }
  };

  const stopStream = () => {
    try {
      streamRef.current?.getTracks()?.forEach((t) => t.stop());
    } catch {}
    streamRef.current = null;
  };

  // ÂÜçÁîüÔºà‚ñ∂/‚è∏ÂàáÊõøÔºâ
  const togglePlay = async () => {
    if (!audioRef.current) return;
    try {
      if (audioRef.current.paused) {
        await audioRef.current.play();
        setIsPlaying(true);
      } else {
        audioRef.current.pause();
        setIsPlaying(false);
      }
    } catch (e) {
      console.error('playback error', e);
    }
  };

  useEffect(() => {
    const a = audioRef.current;
    if (!a) return;
    const onEnded = () => setIsPlaying(false);
    a.addEventListener('ended', onEnded);
    return () => a.removeEventListener('ended', onEnded);
  }, [audioBlob]);

  // --- „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÔºÜ‰øùÂ≠ò ---
  const uploadAndSave = async () => {
    if (!audioBlob || !user) return;
    if (!emotionId || !intensityLevel || !childId) {
      setError('ÊÑüÊÉÖ„Éá„Éº„Çø„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÊÑüÊÉÖÈÅ∏ÊäûÁîªÈù¢„Åã„ÇâÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ');
      return;
    }

    setIsBusy(true);
    setError(null);
    setStatus('„Åô„Åì„Åó„Åæ„Å£„Å¶„Å≠‚Ä¶');

    try {
      const health = await fetch(`${API_BASE}/api/v1/voice/health`);
      if (!health.ok) throw new Error(`„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØÂ§±Êïó: ${health.status}`);

      const upRes = await fetch(`${API_BASE}/api/v1/voice/get-upload-url`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_id: user.id,
          file_type: 'audio',
          file_format: recConfig.ext,
        }),
      });
      if (!upRes.ok) throw new Error(`„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâURLÂèñÂæóÂ§±Êïó: ${upRes.status} ${await upRes.text()}`);
      const upData: GetUploadUrlResponse = await upRes.json();

      const put = await fetch(upData.upload_url, {
        method: 'PUT',
        headers: { 'Content-Type': upData.content_type },
        body: audioBlob,
      });
      if (!put.ok) throw new Error(`S3„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂ§±Êïó: ${put.status} ${await put.text()}`);
      
      const tr = await fetch(`${API_BASE}/api/v1/voice/transcribe`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_id: user.id,
          audio_file_path: upData.file_path,
          language: 'ja',
        }),
      });
      if (!tr.ok) throw new Error(`Èü≥Â£∞Ë™çË≠òÂ§±Êïó: ${tr.status} ${await tr.text()}`);
      const trData: TranscriptionResult = await tr.json();
      setTranscription(trData);
      // ËøΩÂä†ÔºöÈü≥Â£∞‚Üí„ÉÜ„Ç≠„Çπ„Éà„ÅÆ„Éë„ÇπÁîüÊàêÔºÜ„ÉÜ„Ç≠„Çπ„ÉàÊú¨Êñá
      const audioPath = upData.file_path;
      const textPath = audioPath.replace('.webm', '.txt');

      const save = await fetch(`${API_BASE}/api/v1/voice/save-record`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_id: user.id,
          audio_file_path: audioPath,
          text_file_path: textPath,     // null „Åã„Çâ upData.file_path „Å´Â§âÊõ¥
          // voice_note: transcription?.text || '', TODO: Èü≥Â£∞Ë™çË≠ò„ÉÜ„Ç≠„Çπ„Éà„ÅØDB„Å´‰øùÂ≠ò„Åó„Å™„ÅÑ
          emotion_card_id: emotionId,
          intensity_id: intensityLevel,
          child_id: childId,
        }),
      });

      if (!save.ok) throw new Error(`Ë®òÈå≤‰øùÂ≠òÂ§±Êïó: ${save.status} ${await save.text()}`);

      setStatus('„Åß„Åç„ÅüÔºÅ');

      // ÁîªÈù¢ÈÅ∑ÁßªÂá¶ÁêÜ
      const redirectTo = searchParams.get('redirect') || '/app/voice/complete';
      setTimeout(() => router.replace(redirectTo), 100);

    } catch (e: any) {
      console.error('[ERROR] upload/save', e);
      setError(e?.message || '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
      setStatus('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
    } finally {
      setIsBusy(false);
    }
  };

  // „É≠„Éº„Éá„Ç£„É≥„Ç∞Á≥ª
  if (isLoading || !user) {
    return (
      <main style={{ display: 'grid', placeItems: 'center', minHeight: '60vh', color: colors.text.secondary }}>
        <p>Ë™≠„ÅøËæº„Åø‰∏≠...</p>
      </main>
    );
  }
  if (checkingToday) {
    return (
      <main style={{ display: 'grid', placeItems: 'center', minHeight: '60vh', color: colors.text.secondary }}>
        <p>„Åç„Çá„ÅÜ„ÅÆË®òÈå≤„ÇíÁ¢∫Ë™ç‰∏≠‚Ä¶</p>
      </main>
    );
  }

  if (!emotionId || !intensityLevel) {
    return (
      <main style={{
        maxWidth: 720,
        margin: '0 auto',
        padding: spacing.xl,
        background: 'url("/images/background.webp") no-repeat center center',
        backgroundSize: 'cover',
        minHeight: '100vh',
      }}>
        <h1 style={{ fontSize: 22, fontWeight: 700, marginBottom: spacing.sm, color: colors.text.primary }}>
          ÊÑüÊÉÖ„Éá„Éº„Çø„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô
        </h1>
        <p style={{ marginBottom: spacing.md, color: colors.text.secondary }}>
          ÊÑüÊÉÖÈÅ∏ÊäûÁîªÈù¢„Åã„ÇâÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ
        </p>
        <button
          onClick={() => router.push('/app/emotion-selection')}
          style={{
            ...commonStyles.button.base,
            padding: `${spacing.md} ${spacing.lg}`,
            borderRadius: borderRadius.medium,
            backgroundColor: colors.primary,
            color: colors.text.white,
            fontWeight: 700,
            cursor: 'pointer',
          }}
        >
          ÊÑüÊÉÖÈÅ∏Êäû„Å´Êàª„Çã
        </button>
      </main>
    );
  }

  // UIÊú¨‰Ωì
  return (
    <div style={styles.page}>
      {/* keyframesÔºàCSSÔºâ„Çí„Åì„ÅÆÁîªÈù¢„Å†„Åë„Å´Ê≥®ÂÖ• */}
      <style>{`
        @keyframes bob {
          0%,100% { transform: translateY(0); }
          50% { transform: translateY(-8px); }
        }
        @keyframes indet {
          0% { transform: translateX(-60%); }
          100% { transform: translateX(160%); }
        }
      `}</style>

      <main style={styles.panel} aria-busy={isBusy}>
        <button onClick={handleBack} style={styles.backBtn} disabled={isBusy}>‚Üê „ÇÇ„Å©„Çã</button>

        {/* „Éê„Éñ„É´ */}
        <div style={styles.bubbleSmall}>
          <span style={styles.bubbleTextSmall}>„Å©„ÅÜ„Åó„Å¶„Åì„ÅÆ„Åç„ÇÇ„Å°„Å´„Å™„Å£„Åü„ÅÆ„Åã„Å™Ôºü</span>
        </div>

        {/* „Ç≠„É£„É©„ÇØ„Çø„Éº */}
        <div style={styles.characterWrap}>
          <img src="/images/kokoron/kokoron_mic.webp" alt="„Éû„Ç§„ÇØ„ÇíÊåÅ„Å§„Åì„Åì„Çç„Çì" style={styles.characterImg} />
        </div>

        {/* Èå≤Èü≥ÔºàÁôΩÊû†„Ç´„Éº„ÉâÔºã1„Éú„Çø„É≥ÂàáÊõøÔºâ */}
        {!audioBlob && (
          <section style={styles.recordCard}>
            <div style={styles.recordButtonWrap}>
              <button
                onClick={isRecording ? stopRecording : startRecording}
                aria-label={isRecording ? 'Èå≤Èü≥„Çí„Å®„ÇÅ„Çã' : 'Èå≤Èü≥„Çí„ÅØ„Åò„ÇÅ„Çã'}
                disabled={isBusy}
                style={styles.recordOuter}
              >
                <div style={isRecording ? styles.recordInnerActive : styles.recordInnerIdle} />
                {isRecording && (
                  <div style={styles.pauseIconWrap} aria-hidden="true">
                    <div style={styles.pauseBars}>
                      <div style={styles.pauseBar} />
                      <div style={styles.pauseBar} />
                    </div>
                  </div>
                )}
              </button>
            </div>
            <div style={styles.recordHelper}>{isRecording ? '„Å®„ÇÅ„Çã' : '„ÅØ„Å™„Åó„Å¶„Å≠'}</div>
          </section>
        )}

        {/* Á¢∫Ë™ç„Éë„Éç„É´ÔºàÈå≤Èü≥ÂæåÔºâ */}
        {audioBlob && !isRecording && (
          <section style={styles.confirmCard} aria-live="polite">
            <div style={styles.confirmTitle}>„Åç„ÅÑ„Å¶„Åø„Çã</div>

            <button
              onClick={togglePlay}
              style={{
                ...styles.playButtonBase,
                ...(isPlaying ? styles.playButtonActive : styles.playButtonIdle),
              }}
              disabled={isBusy}
              aria-label={isPlaying ? '„Å®„ÇÅ„Çã' : '„Åç„Åè'}
            >
              <span>{isPlaying ? '‚è∏' : '‚ñ∂'}</span>
            </button>

            {/* Èö†„Åóaudio */}
            <audio
              ref={audioRef}
              src={audioBlob ? URL.createObjectURL(audioBlob) : undefined}
              style={{ display: 'none' }}
            />

            <div style={styles.confirmButtons}>
              <button style={styles.btnPrimary} onClick={uploadAndSave} disabled={isBusy}>
                ‚úÖ „ÅÑ„ÅÑ
              </button>
              <button
                style={styles.btnDanger}
                onClick={startRecording}
                disabled={isBusy}
              >
                üî¥ „ÇÇ„ÅÜ„ÅÑ„Å£„Åã„ÅÑ
              </button>
            </div>
          </section>
        )}

        {(status || error) && (
          <div style={styles.statusCard(!!error)}>
            <div style={{ fontWeight: 700 }}>{status}</div>
            {error && <div style={{ marginTop: 6 }}>{error}</div>}
          </div>
        )}

        {transcription && (
          <div
            style={{
              marginTop: 12,
              padding: 12,
              borderRadius: 12,
              border: '1px solid #e5e7eb',
              background: '#fff',
              boxShadow: '0 1px 3px rgba(0,0,0,0.06)',
              width: '92%',
              maxWidth: `${Math.min(LAYOUT.cardMaxWidth, LAYOUT.maxWidth)}px`,
              textAlign: 'center' as const,
            }}
          >
            <div style={{ fontWeight: 700, marginBottom: 6, color: '#111827' }}>ÊñáÂ≠óËµ∑„Åì„Åó</div>
            <div style={{ whiteSpace: 'pre-wrap', lineHeight: 1.6, color: '#111827' }}>
              {transcription.text || '‚Äî'}
            </div>
            {typeof transcription.confidence === 'number' && (
              <div style={{ fontSize: 12, color: '#6b7280', marginTop: 8 }}>
                ‰ø°È†ºÂ∫¶: {(transcription.confidence * 100).toFixed(1)}%
              </div>
            )}
          </div>
        )}
      </main>

      {/* === ÂæÖ„Å°ÊôÇÈñì„ÅÆÊ•Ω„Åó„ÅÑ„Ç™„Éº„Éê„Éº„É¨„Ç§ÔºàisBusy‰∏≠„Å†„ÅëË°®Á§∫Ôºâ === */}
      {isBusy && (
        <div style={styles.overlay} role="dialog" aria-live="polite" aria-label="„Çà„Åø„Åì„Åø‰∏≠">
          <div style={styles.waitCard}>
            <img
              src="/images/kokoron/kokoron_mic.webp"
              alt="„Åì„Åì„Çç„Çì"
              style={styles.waitKokoron}
            />
            <div style={styles.waitBubble}>{WAIT_MESSAGES[msgIndex]}</div>
            <div style={styles.progressWrap}>
              <div style={styles.progressBar} />
            </div>
            <div style={styles.waitHint}>„Çà„Åø„Åì„Åø‰∏≠„Å†„Çà‚Ä¶ „Åù„ÅÆ„Åæ„Åæ „Åæ„Å£„Å¶„Å¶„Å≠</div>
          </div>
        </div>
      )}
    </div>
  );
}